# Spec-Driven Development ‚Äì Project Operating System

> **A professional, AI-powered workflow system for building software projects with clarity, correctness, and confidence.**

This repository provides a complete **Project Operating System (POS)** for building software using **Spec-Driven Development (SDD)** inside Cursor IDE.

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](CONTRIBUTING.md)

---

## üìã Table of Contents

- [What is Spec-Driven Development?](#what-is-spec-driven-development)
- [Key Features](#key-features)
- [System Architecture](#system-architecture)
- [Quick Start](#quick-start)
- [Adopting SDD in Existing Projects](#adopting-sdd-in-existing-projects)
- [Complete Workflow Guide](#complete-workflow-guide)
- [Command Reference](#command-reference)
- [Integrations](#integrations)
- [Token Efficiency](#token-efficiency)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)

---

## What is Spec-Driven Development?

**Spec-Driven Development (SDD)** is a methodology where **the specification is the source of truth**.

```
Idea ‚Üí Specification ‚Üí Plan ‚Üí Task ‚Üí Validation ‚Üí Integration
```

### Core Principles

1. **Specifications define intent** ‚Äì Code implements intent
2. **No assumptions** ‚Äì If it's not in the spec, it doesn't exist
3. **Explicit transitions** ‚Äì Clear phases with defined entry/exit criteria
4. **Continuous evolution** ‚Äì Specs evolve throughout the project lifecycle
5. **Traceability** ‚Äì Every line of code traces back to a spec requirement

### Why SDD?

- ‚úÖ **Avoid vibe-coding** ‚Äì No more "let's just try this and see"
- ‚úÖ **Prevent scope creep** ‚Äì Clear boundaries enforced by the system
- ‚úÖ **Enable AI collaboration** ‚Äì AI agents work best with explicit intent
- ‚úÖ **Maintain alignment** ‚Äì Spec, code, and validation stay synchronized
- ‚úÖ **Professional discipline** ‚Äì Work like a senior engineer from day one

---

## Key Features

### üéØ Smart Command System
- **8 core commands** for complete project lifecycle
- **Auto-detection** of project type, size, phase, and technologies
- **Dynamic rule activation** based on your tech stack
- **Hybrid spec structure** for simple and complex tasks

### üîó Deep Integrations
- **Linear** ‚Äì Automatic issue sync, document creation, status updates
- **GitHub** ‚Äì PR automation, CodeRabbit integration, workflow generation
- **Context7** ‚Äì Dynamic documentation lookup for any framework
- **Testing** ‚Äì Automatic test execution, coverage tracking, failure detection
- **Performance** ‚Äì Lighthouse audits, regression detection, metrics tracking

### üöÄ Automation & Intelligence
- **Git workflow automation** ‚Äì Smart commits, PR descriptions, state tracking
- **Error recovery** ‚Äì Automatic detection and resolution of common issues
- **Refactoring analysis** ‚Äì Code quality checks with framework-agnostic patterns
- **Memory system** ‚Äì OpenMemory integration for accumulated project knowledge

### ‚ö° Token Efficiency
- **Conditional loading** ‚Äì Only load helpers when needed (~33% token reduction)
- **Section-specific reading** ‚Äì Read only relevant parts of large files
- **Metadata caching** ‚Äì Fast rule activation without re-reading files
- **Smart dependencies** ‚Äì Automatic dependency resolution for helpers

---

## System Architecture

### Component Overview

```
.cursor/
‚îú‚îÄ‚îÄ commands/           # Workflow commands (your interface)
‚îÇ   ‚îú‚îÄ‚îÄ spec/          # Specification commands
‚îÇ   ‚îú‚îÄ‚îÄ task/          # Task execution commands
‚îÇ   ‚îú‚îÄ‚îÄ tools/         # Utility commands
‚îÇ   ‚îî‚îÄ‚îÄ _shared/       # 16 shared helpers (conditional loading)
‚îÇ
‚îú‚îÄ‚îÄ rules/             # Behavioral rules (always-on)
‚îÇ   ‚îú‚îÄ‚îÄ 00-pos.mdc     # Project Operating System
‚îÇ   ‚îú‚îÄ‚îÄ 01-sdd.mdc     # Spec-Driven Development
‚îÇ   ‚îú‚îÄ‚îÄ 02-work-mode.mdc # Execution discipline
‚îÇ   ‚îú‚îÄ‚îÄ 10-engineering.mdc # Engineering patterns
‚îÇ   ‚îú‚îÄ‚îÄ 11-design.mdc  # Design system patterns
‚îÇ   ‚îú‚îÄ‚îÄ 12-business.mdc # Business analysis
‚îÇ   ‚îú‚îÄ‚îÄ 20-nextjs.mdc  # Next.js patterns (auto-activated)
‚îÇ   ‚îú‚îÄ‚îÄ 21-api-design.mdc # API design patterns
‚îÇ   ‚îú‚îÄ‚îÄ 30-database.mdc # Database patterns
‚îÇ   ‚îú‚îÄ‚îÄ 31-testing.mdc # Testing patterns
‚îÇ   ‚îî‚îÄ‚îÄ openmemory.mdc # Memory system integration
‚îÇ
‚îî‚îÄ‚îÄ scripts/           # Validation and automation scripts

spec/                  # Source of truth (generated dynamically)
work/                  # Execution artifacts (generated dynamically)
.sdd/                  # Cache and state management
```

### Workflow Diagram

```mermaid
graph TD
    A[üí° Idea] --> B[/spec/init]
    B --> C{Clear enough?}
    C -->|No| D[/spec/refine]
    D --> C
    C -->|Yes| E[/spec/plan]
    E --> F[/task/start]
    F --> G[üõ†Ô∏è Implementation]
    G --> H[/task/validate]
    H --> I{Validation passed?}
    I -->|No| J[Fix issues]
    J --> H
    I -->|Yes| K[/tools/refactor]
    K --> L{Refactoring needed?}
    L -->|Yes| M[Apply refactoring]
    M --> H
    L -->|No| N[‚úÖ Complete]
    N --> O{More tasks?}
    O -->|Yes| F
    O -->|No| P[üöÄ Project Complete]
```

### Integration Flow

```mermaid
graph LR
    A[Command] --> B{Detection}
    B --> C[Rule Activation]
    C --> D[Execution]
    D --> E{Linear enabled?}
    E -->|Yes| F[Linear Automation]
    E -->|No| G{GitHub PR?}
    G -->|Yes| H[CodeRabbit + PR Automation]
    G -->|No| I{Framework detected?}
    I -->|Yes| J[Documentation Lookup]
    I -->|No| K{Tests exist?}
    K -->|Yes| L[Test Automation]
    K -->|No| M{Preview URL?}
    M -->|Yes| N[Performance Monitoring]
    M -->|No| O[Complete]
```

---

## Quick Start

### Prerequisites

- [Cursor IDE](https://cursor.sh/) (latest version)
- Node.js 18+ (for CLI tool)
- Git (for version control)
- Optional: Linear account (for task management)
- Optional: GitHub account (for CI/CD integration)

### Installation

#### Option 1: Using npx (Recommended)

```bash
# Create a new SDD project
npx @eskoubar95/spec init

# Follow the prompts:
# - Project name: my-awesome-project
# - Task mode: local (or linear if you have Linear)
# - Initialize git: yes
```

#### Option 2: Clone Template

```bash
# Clone this repository
git clone https://github.com/nicklaseskou/spec-driven-development.git
cd spec-driven-development

# Copy template to your project
cp -r template/ ../my-awesome-project/
cd ../my-awesome-project
```

### First Steps

1. **Open project in Cursor**
   ```bash
   cursor .
   ```

2. **Initialize your specification**
   ```
   /spec/init
   ```
   
   **Example prompt:**
   ```
   I want to build a SaaS platform for freelancers to manage their 
   clients, projects, and invoices. It should have authentication, 
   a dashboard, project tracking, and PDF invoice generation.
   ```

3. **Refine if needed** (optional)
   ```
   /spec/refine
   ```
   
   **Example prompt:**
   ```
   Can we clarify the authentication requirements? Should we support 
   social login? What about multi-factor authentication?
   ```

4. **Create execution plan**
   ```
   /spec/plan
   ```
   
   **Example prompt:**
   ```
   Create a plan with milestones and tasks. Prioritize authentication 
   and basic dashboard first.
   ```

5. **Start first task**
   ```
   /task/start
   ```
   
   **Example prompt:**
   ```
   Let's start with T1.1 - Set up authentication
   ```

---

## Adopting SDD in Existing Projects

SDD works beautifully for new projects, but it's equally powerful for existing enterprise codebases. Whether you're working with legacy systems, large monoliths, or microservices, SDD can help you document, understand, and improve what already exists.

### When to Use SDD in Existing Projects

- **Legacy codebases** (>6 months old) without comprehensive documentation
- **Team onboarding** needs faster knowledge transfer
- **Planning major refactoring** or migration
- **Adopting SDD incrementally** while maintaining existing workflows
- **Documentation debt** affecting development velocity

### Three Adoption Workflows

```mermaid
graph TD
    A[Existing Project] --> B{Choose Strategy}
    B -->|Complete Documentation| C[Retrospective Workflow]
    B -->|Incremental| D[Feature-by-Feature]
    B -->|Balanced| E[Hybrid Approach]
    C --> F[/spec/audit]
    F --> G[/spec/sync]
    G --> H[/spec/refine]
    H --> I[/spec/plan]
    D --> J[/spec/init with Context]
    J --> K[Normal SDD Workflow]
    E --> L[Start Retrospective]
    L --> M[Adopt for New Features]
```

#### 1. Retrospective Spec Creation (Complete Documentation)

**Best for:** Starting fresh with existing codebase, need comprehensive documentation, planning major changes.

**Workflow:**
```
/spec/audit ‚Üí /spec/sync ‚Üí /spec/refine ‚Üí /spec/plan
```

**Step-by-Step:**

1. **Audit the existing codebase:**
   ```
   /spec/audit
   ```
   
   **Example prompt:**
   ```
   Audit the entire existing codebase. Generate a comprehensive report 
   of what's actually implemented. Focus on:
   - Core features and functionality
   - Architecture patterns
   - Technology stack
   - Key decisions and trade-offs
   - Technical debt and known issues
   ```

2. **Create retrospective specification:**
   ```
   /spec/sync
   ```
   
   **Example prompt:**
   ```
   Create a retrospective specification based on the audit. Document what 
   actually exists, how it works, and why decisions were made. This should 
   be a living document that reflects the current state of the codebase.
   ```

3. **Refine and complete:**
   ```
   /spec/refine
   ```
   
   **Example prompt:**
   ```
   Add missing context to the retrospective spec:
   - Business goals and requirements
   - User personas and use cases
   - Non-functional requirements
   - Risks and technical debt
   - Open questions about future direction
   ```

4. **Plan future work:**
   ```
   /spec/plan
   ```
   
   **Example prompt:**
   ```
   Now that we have a complete spec of what exists, create a plan for 
   the next phase. Focus on:
   - Critical technical debt
   - Missing features
   - Performance improvements
   - New requirements
   ```

**Expected Outcomes:**
- Complete specification of current state
- Architecture documentation
- Technical debt inventory
- Foundation for future development
- Improved team onboarding

**Time Investment:** 1-3 days for medium projects, 1-2 weeks for large enterprise projects.

---

#### 2. Feature-by-Feature Adoption (Incremental)

**Best for:** Large enterprise projects, can't pause development for full retrospective, gradual SDD adoption.

**Workflow:**
```
For each new feature: /spec/init ‚Üí /spec/refine ‚Üí /spec/plan ‚Üí /task/start ‚Üí /task/validate
```

**How it works:**

1. **Initialize spec for new feature:**
   ```
   /spec/init
   ```
   
   **Example prompt:**
   ```
   I'm working on an existing enterprise project. We need to add a new 
   feature: Payment processing with Stripe integration.
   
   Existing context:
   - Architecture: Next.js App Router, PostgreSQL, Redis
   - Patterns: Server actions for mutations, React Server Components
   - Authentication: NextAuth.js with JWT
   - Existing services: User management, order processing
   
   How should this new feature integrate with the existing system?
   ```

2. **System automatically:**
   - Detects existing project context
   - Loads relevant rules based on tech stack
   - Asks integration questions
   - References existing patterns

3. **Continue normal SDD workflow:**
   - `/spec/refine` - Clarify feature requirements
   - `/spec/plan` - Create tasks with acceptance criteria
   - `/task/start` - Implement feature following SDD
   - `/task/validate` - Validate and create PR

**Expected Outcomes:**
- SDD adopted gradually for new work
- Existing codebase stays stable
- New features follow SDD discipline
- Documentation grows incrementally

**Advantages:**
- No disruption to ongoing work
- Low risk adoption
- Learn SDD while delivering features
- Build documentation naturally

---

#### 3. Hybrid Approach (Recommended for Most)

**Best for:** Most enterprise projects - balance between complete documentation and practical delivery.

**Strategy:**

1. **Start with high-level retrospective** (Week 1):
   - Audit core architecture and patterns
   - Document critical features
   - Identify major technical debt
   - Create basic specification structure

2. **Adopt SDD for all new work** (Ongoing):
   - Use feature-by-feature workflow
   - Build on retrospective foundation
   - Expand documentation as you go

3. **Deep-dive retrospectives as needed**:
   - Before major refactorings
   - When onboarding new team members
   - When planning migrations

**Example Timeline:**

**Week 1-2: Foundation**
```
/spec/audit (core architecture)
/spec/sync (high-level spec)
Document critical paths only
```

**Week 3+: Feature Development**
```
Each feature: /spec/init ‚Üí ... ‚Üí /task/validate
Expand documentation as needed
```

**As Needed: Deep Dives**
```
Before refactoring: /spec/audit (specific module)
Document module thoroughly
Refactor with SDD workflow
```

**Expected Outcomes:**
- Balanced documentation coverage
- Practical delivery maintained
- Foundation for scaling SDD
- Flexibility to adapt approach

---

### Enterprise-Specific Considerations

#### Handling Legacy Codebases

**Large Codebases:**
- Don't try to document everything at once
- Prioritize: Core business logic ‚Üí Supporting features ‚Üí Utilities
- Module-by-module documentation
- Focus on what enables future work

**Undocumented Features:**
- Document what exists, not what should exist
- Mark uncertainty clearly
- Use code examples in specs
- Cross-reference code locations

**Technical Debt:**
- Document in `spec/03-risks.md`
- Prioritize by impact
- Link to code references
- Plan remediation in tasks

#### Integrating with Existing Workflows

**Jira/Linear Integration:**
- SDD works with any task management system
- Use Linear MCP for automatic sync (if enabled)
- Link spec files to issues
- Track spec updates as tasks

**Confluence/Wiki:**
- Export specs to Confluence periodically
- Keep SDD specs as source of truth
- Use Confluence for team discussion
- Sync important updates

**GitHub/GitLab:**
- Commit specs alongside code
- Link PRs to spec sections
- Use CodeRabbit for spec compliance
- Track spec evolution in git history

#### Team Adoption Strategies

**Gradual Rollout:**
1. Start with one team or project
2. Document success stories
3. Share learnings across teams
4. Scale based on results

**Training:**
- Run workshops on SDD workflow
- Pair programming sessions
- Code review integration
- Regular retrospectives

**Change Management:**
- Emphasize benefits (faster onboarding, fewer bugs)
- Start small (one feature at a time)
- Gather feedback iteratively
- Adjust based on team needs

---

### Prompt Examples

#### Enterprise Project Audit

```
/spec/audit

I need to audit our existing microservices architecture. We have:
- 8 microservices (auth, payments, notifications, orders, etc.)
- Shared infrastructure (PostgreSQL, Redis, RabbitMQ)
- Legacy monolith being migrated

Focus on:
- Service boundaries and responsibilities
- Inter-service communication patterns
- Data consistency strategies
- Deployment and scaling patterns
- Known issues and technical debt
```

#### Retrospective Spec Creation

```
/spec/sync

Create a retrospective specification for our existing e-commerce platform.

From the audit, document:
- Current feature set (product catalog, cart, checkout, payments)
- Architecture (Next.js App Router, microservices backend)
- Key decisions (why we chose Next.js over Remix, why we split into services)
- Technical debt (legacy payment integration, missing tests)
- Integration points (Stripe, SendGrid, analytics)

Structure it so new team members can understand the system quickly.
```

#### Feature Adoption with Context

```
/spec/init

I'm adding a new feature to our existing SaaS platform: Subscription management.

Existing context:
- Next.js 15 App Router frontend
- Node.js microservices backend
- PostgreSQL for data
- Redis for caching
- Stripe for payments (already integrated)
- NextAuth.js for authentication

The new feature needs to:
- Allow users to subscribe to plans
- Handle subscription upgrades/downgrades
- Integrate with existing Stripe setup
- Follow our existing patterns (server actions, React Server Components)

How should this integrate with our existing architecture?
```

---

### Migration from Other Systems

**From Jira to Linear:**
- Use Linear MCP for automatic sync
- Migrate existing issues gradually
- Keep Jira for historical reference
- Use Linear for new SDD workflows

**From Confluence to SDD:**
- Export important Confluence docs
- Convert to SDD spec format
- Keep Confluence for team collaboration
- Use SDD specs as source of truth

**From Wiki to SDD:**
- Audit existing wiki content
- Identify what's still relevant
- Convert to spec format
- Maintain both during transition

---

### Getting Help

If you're adopting SDD in an existing project:

1. **Start Small:** Begin with one feature or module
2. **Use Audit Commands:** `/spec/audit` is your friend
3. **Reference Helper:** See `_shared/retrospective-spec-creation.md` for detailed guidance
4. **Iterate:** Improve your specs over time
5. **Ask Questions:** Use `/spec/refine` to clarify uncertainties

**Common Questions:**

- **"My project is huge, where do I start?"** ‚Üí Start with critical paths, expand gradually
- **"Can I use SDD for some features but not others?"** ‚Üí Yes! Feature-by-feature adoption is perfect for this
- **"How detailed should retrospective specs be?"** ‚Üí Detailed enough to enable future work, not exhaustive
- **"What if specs become outdated?"** ‚Üí Update specs as you work, use `/spec/sync` periodically

---

## Complete Workflow Guide

### Phase 1: Specification

#### When to use `/spec/init`

**Use when:**
- Starting a brand new project
- You have an idea but no formal specification
- You need to pitch a concept and capture requirements

**Example prompts:**

```
Basic project:
"I want to build a personal blog with Next.js, Tailwind, and MDX for content."

Complex project:
"I'm building a multi-tenant SaaS platform for real estate agents. 
It needs property listings, client management, document storage, 
e-signatures, and payment processing. Target: 1000+ agents."

Migration project:
"I need to migrate our legacy PHP application to Next.js. 
Current features: user auth, product catalog, shopping cart, 
admin panel. Must maintain feature parity."
```

**What it creates:**
- `spec/00-root-spec.md` ‚Äì Core project specification
- `spec/03-risks.md` ‚Äì Identified risks and mitigation strategies
- `spec/04-open-questions.md` ‚Äì Unresolved questions requiring clarification
- `spec/05-decisions.md` ‚Äì Key architectural and technical decisions
- `spec/08-infrastructure.md` ‚Äì Technology stack and infrastructure choices

---

#### When to use `/spec/refine`

**Use when:**
- The spec feels fuzzy or incomplete
- Stakeholders have new questions
- You discover missing requirements
- Scope boundaries are unclear

**Example prompts:**

```
Clarification:
"The authentication section is unclear. Should we support OAuth? 
Which providers? What about email/password?"

Scope adjustment:
"We need to add real-time notifications. How does this impact 
the architecture and timeline?"

Risk mitigation:
"I'm concerned about the file upload feature. What are the 
security implications? Should we use a CDN?"

Technical deep-dive:
"Can we explore the database schema for the multi-tenant setup? 
Should we use row-level security or separate databases?"
```

**What it updates:**
- Refines existing spec sections
- Adds new risks or questions
- Documents decisions made during refinement
- May create `spec/02-architecture.md` if architectural decisions emerge

---

#### When to use `/spec/plan`

**Use when:**
- Specification is clear and stable
- Ready to break down work into tasks
- Need to estimate timeline and milestones

**Example prompts:**

```
Basic planning:
"Create a plan with milestones and tasks. I want to launch an MVP 
in 4 weeks."

Prioritized planning:
"Break this down into phases. Phase 1 should be the minimum viable 
product. Phase 2 can include nice-to-have features."

Team-based planning:
"We have 3 developers. Create parallel workstreams for frontend, 
backend, and infrastructure."

Integration-focused:
"Set up Linear project and create issues for all tasks. Use labels 
for frontend/backend/infrastructure."
```

**What it creates:**
- `work/backlog/milestones.md` ‚Äì Project milestones with goals and deadlines
- `work/backlog/tasks.local.md` ‚Äì Detailed task breakdown (local mode)
- Linear project + issues (if Linear mode enabled)
- `spec/01-prd.md` ‚Äì Product Requirements Document (if needed)
- `spec/06-acceptance.md` ‚Äì Acceptance criteria (if needed)
- `.github/workflows/` ‚Äì CI/CD workflows based on project complexity

---

### Phase 2: Execution

#### When to use `/task/start`

**Use when:**
- Ready to implement a specific task
- Need to lock scope and define acceptance criteria
- Want to initialize Git workflow for the task

**Example prompts:**

```
Simple task:
"Start T1.1 - Set up authentication"

Complex task with clarification:
"Start T2.3 - Implement payment processing. I want to use Stripe. 
Should we support subscriptions or one-time payments?"

Task with dependencies:
"Start T3.2 - Build dashboard. This depends on T1.1 (auth) being 
complete. Verify auth is working first."

Task with specific requirements:
"Start T4.1 - File upload feature. Use AWS S3, support images and 
PDFs up to 10MB, with virus scanning."
```

**What it does:**
- Creates Git branch (e.g., `task/T1.1-setup-authentication`)
- Syncs with Linear issue (if Linear mode)
- Creates task-level spec (if complex task)
- Activates framework-specific rules based on tech stack
- Fetches documentation (Context7) if needed
- Initializes Git state tracking

---

#### When to use `/task/validate`

**Use when:**
- Task implementation is complete
- Ready to verify correctness and quality
- Want to create PR and deploy preview

**Example prompts:**

```
Basic validation:
"Validate the authentication implementation. Run all tests."

Validation with manual testing:
"Validate the dashboard. I've manually tested on Chrome and Safari. 
All features work as expected."

Validation with concerns:
"Validate the payment integration. I'm concerned about error handling. 
Can you review the edge cases?"

Validation with refactoring:
"Validate T2.1. If there are any code quality issues, suggest 
refactoring before creating the PR."
```

**What it does:**
- Runs linting and type checking
- Executes tests (if test framework detected)
- Checks test coverage
- Analyzes code quality
- Handles CodeRabbit comments (if PR exists)
- Generates commit message and PR description
- Creates GitHub PR with preview deployment
- Updates Linear issue status (if Linear mode)
- Runs performance monitoring (if enabled)

---

### Phase 3: Quality & Optimization

#### When to use `/tools/refactor`

**Use when:**
- Task is complete but code feels messy
- Files are getting too large (>300 lines)
- Functions are too complex (>50 lines)
- Code duplication detected
- Want to improve code quality before PR

**Example prompts:**

```
Single file analysis:
"Analyze src/components/Dashboard.tsx for refactoring opportunities."

Feature analysis:
"Analyze the entire authentication feature. Check all files in 
src/auth/ and suggest improvements."

Full codebase analysis:
"Analyze the entire codebase. Focus on components that violate 
single responsibility principle."

Framework-specific analysis:
"Analyze the Next.js app. Are we following Next.js 15 best practices? 
Check server components, data fetching, and routing."
```

**What it checks:**
- File size (warns if >300 lines, critical if >500 lines)
- Function size (warns if >50 lines, critical if >100 lines)
- Cyclomatic complexity (warns if >10, critical if >20)
- Code duplication (DRY principle violations)
- Single Responsibility Principle violations
- Separation of concerns
- Code clarity and readability
- Framework-specific patterns (via Context7 docs)

---

## Command Reference

### Specification Commands

| Command | Purpose | When to Use | Output |
|---------|---------|-------------|--------|
| `/spec/init` | Initialize project spec | Starting new project | `spec/00-root-spec.md`, risks, questions |
| `/spec/refine` | Refine specification | Spec is unclear or incomplete | Updated spec sections |
| `/spec/plan` | Create execution plan | Spec is clear, ready to plan | Milestones, tasks, Linear project |
| `/spec/audit` | Audit spec compliance | Verify spec-code alignment | Audit report with findings |
| `/spec/sync` | Sync spec with reality | Implementation diverged from spec | Updated spec files |
| `/spec/evolve` | Evolve spec for new phase | Project entering new phase | Updated spec for new context |

### Task Commands

| Command | Purpose | When to Use | Output |
|---------|---------|-------------|--------|
| `/task/start` | Start task implementation | Ready to code | Git branch, task context, rules activated |
| `/task/validate` | Validate completed task | Task complete, ready to verify | Validation report, PR creation |

### Tool Commands

| Command | Purpose | When to Use | Output |
|---------|---------|-------------|--------|
| `/tools/refactor` | Analyze code quality | After task completion | Refactoring suggestions, quality metrics |

---

## Integrations

### Linear Integration

**Setup:**

1. Install Linear MCP in Cursor settings
2. Configure in `work/linear/sync-config.md`:
   ```yaml
   LINEAR_MODE: true
   MCP_CONNECTION_NAME: linear  # Your Linear MCP connection name
   AUTO_CREATE_DOCUMENTS: true
   AUTO_UPDATE_STATUS: true
   ```

**Features:**
- ‚úÖ Automatic project creation during `/spec/plan`
- ‚úÖ Issue creation with labels, status, and assignees
- ‚úÖ Document creation for specs and architecture
- ‚úÖ Status updates during task lifecycle
- ‚úÖ Comment sync for task updates
- ‚úÖ Cycle management for sprints

**Example workflow:**
```
/spec/plan ‚Üí Creates Linear project + issues
/task/start T1.1 ‚Üí Syncs with Linear issue, sets status to "In Progress"
/task/validate ‚Üí Updates status to "In Review", adds comment with PR link
```

---

### GitHub Integration

**Setup:**

1. Install GitHub MCP in Cursor settings (or use GitHub CLI)
2. Configure in `.github/workflows/` (auto-generated during `/spec/plan`)

**Features:**
- ‚úÖ Automatic workflow generation (tests, linting, build checks)
- ‚úÖ PR creation with detailed descriptions
- ‚úÖ CodeRabbit comment detection and resolution
- ‚úÖ Preview deployment automation
- ‚úÖ State tracking (branch, PR, deployment)

**Example workflow:**
```
/task/start ‚Üí Creates Git branch, initializes state tracking
[Implementation]
/task/validate ‚Üí Creates PR, triggers workflows, deploys preview
[CodeRabbit reviews]
System auto-resolves CodeRabbit comments as issues are fixed
```

---

### Context7 Documentation Lookup

**Setup:**

1. Install Context7 MCP in Cursor settings
2. No additional configuration needed

**Features:**
- ‚úÖ Automatic framework detection from tech stack
- ‚úÖ Dynamic documentation lookup (no hardcoded library IDs)
- ‚úÖ Cache management for faster lookups
- ‚úÖ Fallback to Cursor indexing and web search

**Example workflow:**
```
/task/start ‚Üí Detects Next.js from spec/08-infrastructure.md
System queries Context7: "Next.js 15 server components best practices"
AI uses fresh documentation for implementation
```

---

## Token Efficiency

### How We Optimize Token Usage

The SDD system is designed to minimize token consumption while maintaining high quality:

#### 1. Conditional Helper Loading (~33% reduction)

**Before optimization:**
```
Every command loads all 16 helpers = ~50,000 tokens per command
```

**After optimization:**
```
Only load helpers when needed:
- /spec/init: 2 helpers = ~6,000 tokens
- /task/start: 5 helpers = ~15,000 tokens
- /task/validate: 8 helpers = ~24,000 tokens
```

#### 2. Section-Specific Reading

Large helpers are divided into sections. Only relevant sections are loaded:

```yaml
# Example: test-automation.md
sections:
  framework_detection: 1-45
  test_execution: 46-120
  coverage_tracking: 121-180
  failure_detection: 181-250
```

If you only need test execution, we load lines 46-120 instead of the entire file.

#### 3. Metadata Caching

Rule metadata is cached in `.sdd/rule-metadata-cache.json`:

```json
{
  "20-nextjs.mdc": {
    "applies_to": ["nextjs", "react"],
    "triggers": ["framework:nextjs", "library:react"]
  }
}
```

This allows instant rule activation without re-reading all rule files.

#### 4. Smart Dependencies

Helpers declare dependencies explicitly:

```yaml
# coderabbit-integration.md
dependencies: [github-helpers]
```

When `coderabbit-integration` is loaded, `github-helpers` is auto-loaded. No manual tracking needed.

### Token Usage by Command

| Command | Helpers Loaded | Approx. Tokens | Use Case |
|---------|----------------|----------------|----------|
| `/spec/init` | 2 | ~6,000 | Project initialization |
| `/spec/refine` | 3 | ~9,000 | Specification refinement |
| `/spec/plan` | 6 | ~18,000 | Planning with integrations |
| `/task/start` | 5 | ~15,000 | Task start with docs lookup |
| `/task/validate` | 8 | ~24,000 | Full validation with all checks |
| `/tools/refactor` | 4 | ~12,000 | Code quality analysis |

**Total savings:** ~33% compared to loading all helpers for every command.

---

## Best Practices

### 1. Start Small, Scale Up

```
‚úÖ Good: Start with /spec/init, refine until clear, then plan
‚ùå Bad: Jump straight to implementation without spec
```

### 2. One Task at a Time

```
‚úÖ Good: /task/start T1.1 ‚Üí Complete ‚Üí /task/validate ‚Üí Next task
‚ùå Bad: Start multiple tasks simultaneously
```

### 3. Validate Before Merging

```
‚úÖ Good: /task/validate ‚Üí Fix issues ‚Üí Validate again ‚Üí Merge
‚ùå Bad: Skip validation and merge directly
```

### 4. Use Refactoring Proactively

```
‚úÖ Good: /task/validate ‚Üí /tools/refactor ‚Üí Fix quality issues ‚Üí Validate again
‚ùå Bad: Accumulate technical debt, refactor later (never happens)
```

### 5. Keep Specs Synchronized

```
‚úÖ Good: Implementation reveals new requirement ‚Üí Update spec first ‚Üí Continue
‚ùå Bad: Implement new feature without updating spec
```

### 6. Leverage Integrations

```
‚úÖ Good: Use Linear for task management, GitHub for CI/CD, Context7 for docs
‚ùå Bad: Manual task tracking, no automation
```

### 7. Trust the Process

```
‚úÖ Good: Follow the workflow even when it feels slow initially
‚ùå Bad: Skip steps because "this is a simple task"
```

---

## Troubleshooting

### Common Issues

#### Issue: "Spec is unclear, can't proceed with planning"

**Solution:**
```
/spec/refine

Prompt: "The authentication section is unclear. What specific 
authentication methods should we support? What are the security 
requirements?"
```

---

#### Issue: "Task validation failed, tests are failing"

**Solution:**
```
1. Review test failures in validation report
2. Fix failing tests
3. Run /task/validate again
4. Repeat until all tests pass
```

---

#### Issue: "CodeRabbit found issues in PR, but I disagree"

**Solution:**
```
The system will automatically:
1. Detect CodeRabbit comments
2. Categorize as minor/major/bottleneck
3. If you don't fix, system argues why and logs to Linear/local

You can also manually respond to CodeRabbit in GitHub PR comments.
```

---

#### Issue: "Linear sync is not working"

**Solution:**
```
1. Check work/linear/sync-config.md:
   - LINEAR_MODE: true
   - MCP_CONNECTION_NAME: <your-connection-name>

2. Verify Linear MCP is installed in Cursor settings

3. Check .sdd/linear-state.json for errors

4. Re-run /spec/plan to recreate Linear project
```

---

#### Issue: "Documentation lookup is not finding the right docs"

**Solution:**
```
1. Verify tech stack is documented in spec/08-infrastructure.md

2. Check Context7 MCP is installed and working:
   Test manually: "Find Next.js 15 documentation"

3. System will fallback to:
   - Cursor's indexed documentation
   - Web search

4. If still failing, provide explicit documentation links in spec
```

---

#### Issue: "Git workflow is creating wrong branch names"

**Solution:**
```
1. Check .sdd/git-state.json for current state

2. Manually create branch if needed:
   git checkout -b task/T1.1-your-task-name

3. Re-run /task/start to sync state

4. System will detect existing branch and use it
```

---

### Getting Help

- **Documentation:** See `SYSTEM.md` for detailed architecture
- **Issues:** [GitHub Issues](https://github.com/nicklaseskou/spec-driven-development/issues)
- **Discussions:** [GitHub Discussions](https://github.com/nicklaseskou/spec-driven-development/discussions)

---

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

### Development Setup

```bash
# Clone repository
git clone https://github.com/nicklaseskou/spec-driven-development.git
cd spec-driven-development

# Install CLI dependencies
cd cli
npm install

# Build CLI
npm run build

# Test CLI locally
node dist/index.js init
```

### Running Validation Scripts

```bash
# Validate helper metadata
node .cursor/scripts/validate-helpers.js

# Expected output: All checks passed ‚úì
```

---

## License

MIT License - see [LICENSE](LICENSE) for details.

---

## Acknowledgments

- Inspired by [spec-kit-command-cursor](https://github.com/madebyaris/spec-kit-command-cursor)
- Built for the Cursor IDE community
- Powered by Claude Sonnet 4.5

---

## What's Next?

1. **Initialize your first project:**
   ```bash
   npx @eskoubar95/spec init
   ```

2. **Open in Cursor and start:**
   ```
   /spec/init
   ```

3. **Join the community:**
   - Share your experience
   - Suggest improvements
   - Help others get started

**Happy building! üöÄ**
